// game.js
// Utility Function for Delay
function sleep(ms) {
    return new Promise(resolve => setTimeout(resolve, ms));
}

// Password Save/Load Functions
function generatePassword() {
    if (!game.player) return "";
    const playerData = {
        name: game.player.name,
        hp: game.player.hp,
        maxHp: game.player.maxHp,
        rank: game.player.rank,
        fightingStyles: game.player.fightingStyles,
        activeJutsu: game.player.activeJutsu.map(j => ({ name: j.name, style: j.style, support: j.support, rank: j.rank })),
        inventory: game.player.inventory.map(j => ({ name: j.name, style: j.style, support: j.support, rank: j.rank })),
        statusEffects: game.player.statusEffects.map(s => ({ name: s.name, duration: s.duration, damage: s.damage })),
        sprite: game.player.sprite,
        xp: game.player.xp,
        travelFightsCompleted: game.player.travelFightsCompleted,
        lastVillage: game.player.lastVillage
    };
    const password = JSON.stringify(playerData);
    return btoa(password); // Base64 encode
}

function loadPassword(password) {
    try {
        if (!password) throw new Error("No password provided");
        const decoded = atob(password);
        const playerData = JSON.parse(decoded);
        const skills = new Skills(); // Reinitialize Skills to access full BattleSkill definitions
        // Directly update game.player and global player attributes
        game.player.name = playerData.name;
        game.player.hp = playerData.hp;
        game.player.maxHp = playerData.maxHp;
        game.player.rank = playerData.rank;
        game.player.fightingStyles = playerData.fightingStyles;
        game.player.activeJutsu = playerData.activeJutsu.map(j => skills.findSkill(j.name) || new BattleSkill(j.name, [], {}, () => {}, j.style, j.support, j.rank));
        game.player.inventory = playerData.inventory.map(j => skills.findSkill(j.name) || new BattleSkill(j.name, [], {}, () => {}, j.style, j.support, j.rank));
        game.player.statusEffects = playerData.statusEffects.map(s => new StatusEffect(s.name, s.duration, s.damage));
        game.player.sprite = playerData.sprite;
        game.player.xp = playerData.xp;
        game.player.travelFightsCompleted = playerData.travelFightsCompleted;
        game.player.lastVillage = playerData.lastVillage;
        // Sync global player with game.player
        player = game.player; // Ensure global player matches game.player
        game.opponent = null;
        inBattle = false;
        // Force UI updates to reflect loaded data
        updateBattleUI();
        ArriveVillage(game.player.lastVillage);
        updateJutsuDisplay();
        document.getElementById("password-menu").style.display = "none";
        logBattle(`<span class="output-text-neutral">Character loaded from password!</span>`);
    } catch (e) {
        logBattle(`<span class="output-text-neutral">Invalid password format: ${e.message}</span>`);
    }
}

// UI Handling for Password Menu
document.addEventListener("DOMContentLoaded", () => {
    const passwordMenu = document.getElementById("password-menu");
    if (passwordMenu) {
        passwordMenu.addEventListener("click", (e) => {
            if (e.target.id === "generate-password") {
                const password = generatePassword();
                document.getElementById("password-input").value = password;
                logBattle(`<span class="output-text-neutral">Password generated! Copy it to save your progress.</span>`);
            } else if (e.target.id === "load-password") {
                const password = document.getElementById("password-input").value;
                if (password) loadPassword(password);
            } else if (e.target.id === "close-password") {
                passwordMenu.style.display = "none";
            }
        });
    }
});

function togglePasswordMenu() {
    const menu = document.getElementById("password-menu");
    if (menu) {
        if (menu.style.display === "none") {
            closeAllMenus();
            menu.style.display = "block";
        } else {
            menu.style.display = "none";
        }
    }
}



class StatusEffect {
    constructor(name, duration, damage = 0, startOfTurn = false, active = false, triggered = false, endOfTurn = false,
                startOfTurnFunction = null, activeFunction = null, triggeredFunction = null, endOfTurnFunction = null, emoji = null) {
        this.name = name;
        this.duration = duration;
        this.damage = damage;
        this.new = true;
        this.startOfTurn = startOfTurn;
        this.active = active;
        this.triggered = triggered;
        this.endOfTurn = endOfTurn;
        this.startOfTurnFunction = startOfTurnFunction;
        this.activeFunction = activeFunction;
        this.triggeredFunction = triggeredFunction;
        this.endOfTurnFunction = endOfTurnFunction;
        this.emoji = emoji; // Added to store the emoji
    }

    // Predefined StatusEffect templates as static getters
    static get Swap() {
        return (turns, damage) => new StatusEffect(
            "Swap",
            turns,
            damage,
            false,
            false,
            true,
            false,
            null,
            null,
            async (target, user, skillStyle) => {
                logBattle(`<span class="output-text-${target === player ? 'player' : 'enemy'}">${target.name}</span> uses Substitution to dodge the attack with a log!`);
                updateBattleUI();
                target.statusEffects = target.statusEffects.filter(e => e.name !== "Swap");
                await sleep(2000);
                return true;
            },
            null,
            statusEmojis["Swap"]
        );
    }

    static get ShadowClone() {
        return (turns, damage) => new StatusEffect(
            "ShadowClone",
            turns,
            damage,
            false,
            true,
            true,
            false,
            null,
            async (user, target) => {
                let cloneCount = user.statusEffects.filter(e => e.name === "ShadowClone").length;
                for (let i = 0; i < cloneCount; i++) {
                    logBattle(`<span class="output-text-${user === player ? 'player' : 'enemy'}">Shadow Clone ${i + 1} uses Barrage on ${target.name}!</span>`);
                    updateBattleUI();
                    await skillsInstance.barrage(user, target); // Note: 'this' might need context from Skills class; consider passing Skills instance
                    if (DeathCheck()) return true;
                    await sleep(2000);
                }
                user.statusEffects = user.statusEffects.filter(e => e.name !== "ShadowClone");
                return false;
            },
            async (target, user, skillStyle) => {
                let cloneCount = target.statusEffects.filter(e => e.name === "ShadowClone").length;
                if (cloneCount > 0) {
                    logBattle(`<span class="output-text-${target === player ? 'player' : 'enemy'}">${target.name}</span>'s Shadow Clone absorbs the attack!`);
                    target.statusEffects.splice(target.statusEffects.findIndex(e => e.name === "ShadowClone"), 1);
                    updateBattleUI();
                    await sleep(2000);
                    await endTurn();
                    return true;
                }
                return false;
            },
            null,
            statusEmojis["ShadowClone"]
        );
    }

    static get Doom() {
        return (turns, damage) => new StatusEffect(
            "Doom",
            turns,
            damage,
            true,
            false,
            false,
            false,
            async (user, target, status) => {
                user.hp = Math.max(0, user.hp - status.damage);
                logBattle(`<span class="output-text-${user === player ? 'player' : 'enemy'}">${user.name}</span> takes ${status.damage} from <span class="status-doom">Doom üíÄ</span>!`);
                updateBattleUI();
                if (DeathCheck()) return true;
                await sleep(2000);
                return false;
            },
            null,
            null,
            null,
            statusEmojis["Doom"]
        );
    }

    static get Regen() {
        return (turns, damage) => new StatusEffect(
            "Regen",
            turns,
            damage,
            true,
            false,
            false,
            false,
            async (user, target, status) => {
                let heal = user.hp < user.maxHp ? status.damage : 0;
                user.hp = Math.min(user.maxHp, user.hp + heal);
                if (heal > 0) {
                    logBattle(`<span class="output-text-${user === player ? 'player' : 'enemy'}">${user.name}</span> heals ${heal} HP from <span class="status-regen">Regen üåø</span>!`);
                    updateBattleUI();
                    if (DeathCheck()) return true;
                    await sleep(2000);
                }
                return false;
            },
            null,
            null,
            null,
            statusEmojis["Regen"]
        );
    }

    static get Dome() {
        return (turns, damage) => new StatusEffect(
            "Dome",
            turns,
            damage,
            false,
            false,
            true,
            false,
            null,
            null,
            async (target, user, skillStyle) => {
                if (skillStyle !== "genjutsu") {
                    logBattle(`<span class="output-text-${target === player ? 'player' : 'enemy'}">${target.name}</span> uses Earth Dome to mitigate the attack!`);
                    target.statusEffects = target.statusEffects.filter(e => e.name !== "Dome");
                    updateBattleUI();
                    await sleep(2000);
                    await endTurn();
                    return true;
                }
                return false;
            },
            null,
            statusEmojis["Dome"]
        );
    }

    static get Burn() {
        return (turns, damage) => new StatusEffect(
            "Burn",
            turns,
            damage,
            true,
            false,
            false,
            false,
            async (user, target, status) => {
                user.hp = Math.max(0, user.hp - status.damage);
                logBattle(`<span class="output-text-${user === player ? 'player' : 'enemy'}">${user.name}</span> takes ${status.damage} from <span class="status-burn">Burn üî•</span>!`);
                updateBattleUI();
                if (DeathCheck()) return true;
                await sleep(2000);
                return false;
            },
            null,
            null,
            null,
            statusEmojis["Burn"]
        );
    }

    static get Numb() {
        return (turns, damage) => new StatusEffect(
            "Numb",
            turns,
            damage,
            true,
            false,
            false,
            false,
            async (user, target) => {
                logBattle(`<span class="output-text-${user === player ? 'player' : 'enemy'}">${user.name}</span> is stunned by <span class="status-numb">Numb ‚ö°Ô∏è</span> and skips their turn!`);
                user.statusEffects = user.statusEffects.filter(e => e.name !== "Numb");
                updateBattleUI();
                await sleep(2000);
                return true;
            },
            null,
            null,
            null,
            statusEmojis["Numb"]
        );
    }

    static get Ready() {
        return (turns, damage) => new StatusEffect(
            "READY",
            turns,
            damage,
            false,
            true,
            false,
            false,
            null,
            (user, target) => {
                for (let status of target.statusEffects) {
                    if (status.triggered && status.triggeredFunction) {
                        status.triggeredFunction(target, user);
                        if (DeathCheck()) return true;
                        sleep(2000);
                        logBattle(`<span class="output-text-${user === player ? 'player' : 'enemy'}">${user.name}</span> breaks <span class="status-ready">READY üí™</span> triggered effects!`);
                        return false;
                    }
                }
                logBattle(`<span class="output-text-${user === player ? 'player' : 'enemy'}">${user.name}</span> unleashes a Barrage <span class="status-ready">üí™</span>!`);
                sleep(1000);
                updateBattleUI();
                skillsInstance.barrage(user, target); // Note: 'this' might need context from Skills class
                if (DeathCheck()) return true;
                sleep(2000);
                return false;
            },
            null,
            null,
            statusEmojis["READY"]
        );
    }

    static get Release() {
        return (turns, damage) => new StatusEffect(
            "Release",
            turns,
            damage,
            false,
            false,
            true,
            false,
            null,
            null,
            async (target, user, skillStyle) => {
                if (skillStyle === "genjutsu") {
                    logBattle(`<span class="output-text-${target === player ? 'player' : 'enemy'}">${target.name}</span> uses Release to resist the Genjutsu attack!`);
                    target.statusEffects = target.statusEffects.filter(e => e.name !== "Release");
                    updateBattleUI();
                    await sleep(2000);
                    await endTurn();
                    return true;
                }
                return false;
            },
            null,
            statusEmojis["Release"]
        );
    }

    static get Bleed() {
        return (turns, damage) => new StatusEffect(
            "Bleed",
            turns,
            damage,
            true,
            false,
            false,
            false,
            async (user, target, status) => {
                user.hp = Math.max(0, user.hp - status.damage);
                logBattle(`<span class="output-text-${user === player ? 'player' : 'enemy'}">${user.name}</span> takes ${status.damage} from <span class="status-bleed">Bleed ü©∏</span>!`);
                updateBattleUI();
                if (DeathCheck()) return true;
                await sleep(2000);
                return false;
            },
            null,
            null,
            null,
            statusEmojis["Bleed"]
        );
    }

    static get Recovered() {
        return (turns, damage) => new StatusEffect(
            "Recovered",
            turns,
            damage,
            false,
            false,
            false,
            true,
            null,
            null,
            null,
            async (user, target, status) => {
                const userHasBoth = game.user.statusEffects.some(e => e.name === "Numb") && game.user.statusEffects.some(e => e.name === "Recovered");
                const targetHasBoth = game.target.statusEffects.some(e => e.name === "Numb") && game.target.statusEffects.some(e => e.name === "Recovered");
                if (userHasBoth) {
                    game.user.statusEffects = game.user.statusEffects.filter(e => e.name !== "Numb" && e.name !== "Recovered");
                }
                if (targetHasBoth) {
                    game.target.statusEffects = game.target.statusEffects.filter(e => e.name !== "Numb" && e.name !== "Recovered");
                }
                updateBattleUI();
                await sleep(2000);
                return false;
            },
            statusEmojis["Recovered"]
        );
    }
}

// Status Emojis (keep this after the StatusEffect class)
const statusEmojis = {
    "Swap": "ü™µ",
    "ShadowClone": "üë•",
    "Doom": "üíÄ",
    "Regen": "üåø",
    "Dome": "ü™®",
    "Burn": "üî•",
    "Numb": "‚ö°Ô∏è",
    "READY": "üí™",
    "Release": "üåÄ",
    "Bleed": "ü©∏",
    "Recovered": "üí´"
};

// Battle Skill Class
class BattleSkill {
    constructor(name, attributes, requirements, skillFunction, style, support, rank) {
        this.name = name;
        this.attributes = attributes || [];
        this.requirements = requirements || {};
        this.skillFunction = skillFunction;
        this.style = style;
        this.support = support || false;
        this.rank = rank;
    }
}

// Mob Class
class Mob {
    constructor(name, hp, maxHp, rank, fightingStyles, activeJutsu, inventory, statusEffects, sprite) {
        this.name = name;
        this.hp = hp;
        this.maxHp = maxHp;
        this.rank = rank;
        this.fightingStyles = fightingStyles;
        this.activeJutsu = activeJutsu || [];
        this.inventory = inventory || [];
        this.statusEffects = statusEffects || [];
        this.sprite = sprite || null;
        this.xp = 0;
        this.travelFightsCompleted = 0;
        this.lastVillage = "Newb Village";
    }
}

// Skills Class
class Skills {
    constructor() {
        this.skills = [];
        this.initializeSkills();
    }

    initializeSkills() {
        this.skills = [
            new BattleSkill("Barrage", ["Taijutsu"], {}, this.barrage.bind(this), "taijutsu", false, "D-Rank"),
            new BattleSkill("Substitution Jutsu", [], { Ninjutsu: "D-Rank", Taijutsu: "D-Rank" }, this.substitutionJutsu.bind(this), "ninjutsu", true, "D-Rank"),
            new BattleSkill("Shadow Clone Jutsu", ["Ninjutsu"], { Ninjutsu: "C-Rank" }, this.shadowCloneJutsu.bind(this), "ninjutsu", true, "C-Rank"),
            new BattleSkill("Demonic Vision", ["Genjutsu"], { Genjutsu: "C-Rank" }, this.demonicVision.bind(this), "genjutsu", false, "C-Rank"),
            new BattleSkill("Healing Stance", ["Ninjutsu"], {}, this.healingStance.bind(this), "neutral", true, "D-Rank"),
            new BattleSkill("Earth Dome Jutsu", ["Earth", "Ninjutsu"], { Earth: "C-Rank" }, this.earthDomeJutsu.bind(this), "earth", true, "C-Rank"),
            new BattleSkill("Flame Throw Jutsu", ["Fire"], { Fire: "B-Rank" }, this.flameThrowJutsu.bind(this), "fire", false, "B-Rank"),
            new BattleSkill("Static Field Jutsu", ["Lightning", "Ninjutsu"], { Lightning: "C-Rank" }, this.staticFieldJutsu.bind(this), "lightning", false, "C-Rank"),
            new BattleSkill("Fireball Jutsu", ["Fire", "Ninjutsu"], { Fire: "C-Rank" }, this.fireballJutsu.bind(this), "fire", false, "C-Rank"),
            new BattleSkill("Dynamic Entry", ["Taijutsu"], { Taijutsu: "C-Rank" }, this.dynamicEntry.bind(this), "taijutsu", true, "C-Rank"),
            new BattleSkill("Falcon Drop", ["Taijutsu"], { Taijutsu: "B-Rank" }, this.falconDrop.bind(this), "taijutsu", false, "B-Rank"),
            new BattleSkill("Rock Smash Jutsu", ["Earth", "Taijutsu"], { Earth: "B-Rank" }, this.rockSmashJutsu.bind(this), "earth", false, "B-Rank"),
            new BattleSkill("Genjutsu Release", ["Genjutsu"], { Genjutsu: "B-Rank" }, this.genjutsuRelease.bind(this), "genjutsu", true, "B-Rank"),
            new BattleSkill("Lightning Edge", ["Lightning", "Ninjutsu"], { Lightning: "C-Rank", Ninjutsu: "C-Rank" }, this.lightningEdge.bind(this), "lightning", true, "B-Rank"),
            new BattleSkill("Bite", ["Beast"], { Beast: "C-Rank" }, this.bite.bind(this), "beast", false, "C-Rank"),
            new BattleSkill("Night Terror Jutsu", ["Genjutsu"], { Genjutsu: "B-Rank" }, this.nightTerrorJutsu.bind(this), "genjutsu", false, "B-Rank"),
            new BattleSkill("Wild Fire Jutsu", ["Fire", "Ninjutsu"], { Fire: "C-Rank", Ninjutsu: "C-Rank" }, this.wildFireJutsu.bind(this), "fire", true, "C-Rank"),
            new BattleSkill("Hell Fire Jutsu", ["Genjutsu"], { Genjutsu: "B-Rank" }, this.hellFireJutsu.bind(this), "genjutsu", true, "B-Rank")
        ];
        if (this.skills.length === 0) {
            console.error("Skills initialization failed!");
            logBattle("Error: No skills initialized!");
        }
    }

    canUseSkill(mob, skill) {
        const result = Object.keys(skill.requirements).every(key => mob.fightingStyles[key] && compareRanks(mob.fightingStyles[key], skill.requirements[key]) >= 0);
        if (!result) {
            console.log(`Cannot use ${skill.name}: Requirements not met`, skill.requirements, mob.fightingStyles);
        }
        return result;
    }

    findSkill(name) {
        return this.skills.find(skill => skill.name === name);
    }

    async barrage(user, target) {
        let baseDamage = Math.floor(Math.random() * 2) + 1;
        let comboDamage = Math.floor(Math.random() * 2) + 1;
        target.hp = Math.max(0, Math.min(target.maxHp, target.hp - baseDamage));
        logBattle(`<span class="output-text-${user === player ? 'player' : 'enemy'}">${user.name}</span> attacks <span class="output-text-${target === player ? 'player' : 'enemy'}">${target.name}</span> with <span class="output-text-neutral">Barrage</span> for ${baseDamage} damage!`);
        updateBattleUI();
        if (DeathCheck()) return true;
        await sleep(2000);
        if (target.hp > 0) {
            target.hp = Math.max(0, Math.min(target.maxHp, target.hp - comboDamage));
            logBattle(`<span class="output-text-${user === player ? 'player' : 'enemy'}">${user.name}</span> combos ${target.name} for ${comboDamage} damage!`);
            updateBattleUI();
            if (DeathCheck()) return true;
            await sleep(2000);
        }
        return false;
    }

    async substitutionJutsu(user, target) {
        user.statusEffects.push(StatusEffect.Swap(1, 0));
        logBattle(`<span class="output-text-${user === player ? 'player' : 'enemy'}">${user.name}</span> prepares <span class="output-text-neutral">Substitution Jutsu</span> <span class="status-substitution">ü™µ</span>!`);
        updateBattleUI();
        if (DeathCheck()) return true;
        await sleep(2000);
        return true;
    }

    async shadowCloneJutsu(user, target) {
        if (user.hp < 2) {
            logBattle(`<span class="output-text-${user === player ? 'player' : 'enemy'}">${user.name}</span> does not have enough HP to cast <span class="output-text-neutral">Shadow Clone Jutsu</span>!`);
            updateBattleUI();
            await sleep(2000);
            return false;
        }
        let cloneCount = user.statusEffects.filter(e => e.name === "ShadowClone").length;
        if (cloneCount >= 3) {
            logBattle(`<span class="output-text-${user === player ? 'player' : 'enemy'}">${user.name}</span> already has the maximum of 3 shadow clones!`);
            updateBattleUI();
            await sleep(2000);
            return false;
        }
        user.hp = Math.max(0, Math.min(user.maxHp, user.hp - 2));
        logBattle(`<span class="output-text-${user === player ? 'player' : 'enemy'}">${user.name}</span> casts <span class="output-text-neutral">Shadow Clone Jutsu</span>, adding a clone <span class="status-shadowcloneeffect">üë•</span>!`);
        updateBattleUI();
        if (DeathCheck()) return true;
        await sleep(2000);
        user.statusEffects.push(StatusEffect.ShadowClone(3, 0, this));
        updateBattleUI();
        if (DeathCheck()) return true;
        await sleep(2000);
        return false;
    }

    async demonicVision(user, target) {
        let damage = 1;
        target.hp = Math.max(0, Math.min(target.maxHp, target.hp - damage));
        target.statusEffects.push(StatusEffect.Doom(5, 1));
        logBattle(`<span class="output-text-${user === player ? 'player' : 'enemy'}">${user.name}</span> casts <span class="output-text-genjutsu">Demonic Vision</span> on <span class="output-text-${target === player ? 'player' : 'enemy'}">${target.name}</span> for ${damage} damage, inflicting <span class="status-doom">Doom üíÄ</span>!`);
        updateBattleUI();
        if (DeathCheck()) return true;
        await sleep(2000);
        return false;
    }

    async healingStance(user, target) {
        let heal = user.hp < user.maxHp ? 1 : 0;
        user.hp = Math.min(user.maxHp, user.hp + heal);
        user.statusEffects.push(StatusEffect.Regen(2, 1));
        logBattle(`<span class="output-text-${user === player ? 'player' : 'enemy'}">${user.name}</span> enters <span class="output-text-neutral">Healing Stance</span>${heal > 0 ? `, healing ${heal} HP` : ""} <span class="status-regen">üåø</span>!`);
        updateBattleUI();
        if (DeathCheck()) return true;
        await sleep(2000);
        return true;
    }

    async earthDomeJutsu(user, target) {
        if (user.statusEffects.some(e => e.name === "Dome")) {
            logBattle(`<span class="output-text-${user === player ? 'player' : 'enemy'}">${user.name}</span> cannot stack <span class="output-text-earth">Earth Dome Jutsu</span>!`);
            return true;
        }
        user.statusEffects.push(StatusEffect.Dome(2, 0));
        logBattle(`<span class="output-text-${user === player ? 'player' : 'enemy'}">${user.name}</span> raises <span class="output-text-earth">Earth Dome Jutsu</span> <span class="status-dome">ü™®</span> for 2 turns!`);
        updateBattleUI();
        if (DeathCheck()) return true;
        await sleep(2000);
        return true;
    }

    async flameThrowJutsu(user, target) {
        let damage = Math.floor(Math.random() * 2) + 4;
        target.hp = Math.max(0, Math.min(target.maxHp, target.hp - damage));
        target.statusEffects.push(StatusEffect.Burn(1, 2));
        user.statusEffects.push(StatusEffect.Burn(1, 1)); // Adjusted to 1 damage for user as per intent
        logBattle(`<span class="output-text-${user === player ? 'player' : 'enemy'}">${user.name}</span> casts <span class="output-text-fire">Flame Throw Jutsu</span> on <span class="output-text-${target === player ? 'player' : 'enemy'}">${target.name}</span> for ${damage} damage, inflicting <span class="status-burn">Burn üî•</span> (2 damage) on target and <span class="status-burn">Burn üî•</span> (1 damage) on self!`);
        updateBattleUI();
        if (DeathCheck()) return true;
        await sleep(2000);
        return false;
    }

    async staticFieldJutsu(user, target) {
        let damage = Math.floor(Math.random() * 2) + 2;
        target.hp = Math.max(0, Math.min(target.maxHp, target.hp - damage));
        user.statusEffects.push(StatusEffect.Numb(1, 0));
        target.statusEffects.push(StatusEffect.Numb(1, 0));
        logBattle(`<span class="output-text-${user === player ? 'player' : 'enemy'}">${user.name}</span> uses <span class="output-text-lightning">Static Field Jutsu</span> on <span class="output-text-${target === player ? 'player' : 'enemy'}">${target.name}</span> for ${damage} damage, inflicting <span class="status-numb">Numb ‚ö°Ô∏è</span> on both!`);
        updateBattleUI();
        if (DeathCheck()) return true;
        await sleep(2000);
        return false;
    }

    async fireballJutsu(user, target) {
        let damage = Math.floor(Math.random() * 2) + 2;
        target.hp = Math.max(0, Math.min(target.maxHp, target.hp - damage));
        target.statusEffects.push(StatusEffect.Burn(1, 1));
        logBattle(`<span class="output-text-${user === player ? 'player' : 'enemy'}">${user.name}</span> casts <span class="output-text-fire">Fireball Jutsu</span> on <span class="output-text-${target === player ? 'player' : 'enemy'}">${target.name}</span> for ${damage} damage, inflicting <span class="status-burn">Burn üî•</span>!`);
        updateBattleUI();
        if (DeathCheck()) return true;
        await sleep(2000);
        return false;
    }

    async dynamicEntry(user, target) {
        target.statusEffects = target.statusEffects.filter(e => e.name !== "Swap" && e.name !== "Dome");
        updateBattleUI();
        await sleep(2000);
        // Run Target Triggered Effect Check
        for (let status of target.statusEffects) {
            if (status.triggered && status.triggeredFunction) {
                await status.triggeredFunction(target, user, "taijutsu");
                if (DeathCheck()) return true;
            }
        }
        // If no triggered effects, deal 1 damage before chaining
        let damage = 0;
        if (target.statusEffects.every(status => !status.triggered || !status.triggeredFunction || !await status.triggeredFunction(target, user, "taijutsu"))) {
            damage = 1;
            target.hp = Math.max(0, Math.min(target.maxHp, target.hp - damage));
            logBattle(`<span class="output-text-${user === player ? 'player' : 'enemy'}">${user.name}</span> deals ${damage} damage to <span class="output-text-${target === player ? 'player' : 'enemy'}">${target.name}</span> with <span class="output-text-neutral">Dynamic Entry</span>!`);
            updateBattleUI();
            if (DeathCheck()) return true;
            await sleep(2000);
        }
        // Chain next skill
        let usableSkills = user.activeJutsu.filter(skill => !skill.support && skill.name !== "Dynamic Entry");
        let nextSkill = usableSkills.length > 0 ? usableSkills[Math.floor(Math.random() * usableSkills.length)] : null;
        if (nextSkill) {
            logBattle(`<span class="output-text-${user === player ? 'player' : 'enemy'}">${user.name}</span> chains with ${nextSkill.name}!`);
            updateBattleUI();
            await nextSkill.skillFunction(user, target);
            if (DeathCheck()) return true;
            await sleep(2000);
        }
        return false;
    }

    async falconDrop(user, target) {
        let damage = 2;
        user.hp = Math.max(0, Math.min(user.maxHp, user.hp - 2));
        target.hp = Math.max(0, Math.min(target.maxHp, target.hp - damage));
        target.statusEffects.push(StatusEffect.Numb(1, 0));
        if (!user.statusEffects.some(e => e.name === "READY")) {
            user.statusEffects.push(StatusEffect.Ready(2, 0, this));
        }
        logBattle(`<span class="output-text-${user === player ? 'player' : 'enemy'}">${user.name}</span> uses <span class="output-text-taijutsu">Falcon Drop</span> on <span class="output-text-${target === player ? 'player' : 'enemy'}">${target.name}</span> for ${damage} damage, stunning target and taking ${damage} damage! <span class="status-ready">READY üí™</span> applied!`);
        updateBattleUI();
        if (DeathCheck()) return true;
        await sleep(2000);
        return false;
    }

    async rockSmashJutsu(user, target) {
        let damage = 6;
        target.hp = Math.max(0, Math.min(target.maxHp, target.hp - damage));
        logBattle(`<span class="output-text-${user === player ? 'player' : 'enemy'}">${user.name}</span> uses <span class="output-text-earth">Rock Smash Jutsu</span> on <span class="output-text-${target === player ? 'player' : 'enemy'}">${target.name}</span> for ${damage} damage!`);
        updateBattleUI();
        if (DeathCheck()) return true;
        await sleep(2000);
        return false;
    }

    async genjutsuRelease(user, target) {
        user.statusEffects = user.statusEffects.filter(e => e.name !== "Doom");
        user.statusEffects.push(StatusEffect.Release(1, 0));
        logBattle(`<span class="output-text-${user === player ? 'player' : 'enemy'}">${user.name}</span> uses <span class="output-text-genjutsu">Genjutsu Release</span>, dispelling Doom and gaining <span class="status-release">Release üåÄ</span>!`);
        updateBattleUI();
        if (DeathCheck()) return true;
        await sleep(2000);
        return true;
    }

    async lightningEdge(user, target) {
        target.statusEffects = target.statusEffects.filter(e => e.name !== "Swap" && e.name !== "Dome");
        logBattle(`<span class="output-text-${user === player ? 'player' : 'enemy'}">${user.name}</span> dispels <span class="output-text-${target === player ? 'player' : 'enemy'}">${target.name}</span>'s <span class="output-text-neutral">Substitution</span> and <span class="output-text-neutral">Earth Dome</span> with <span class="output-text-neutral">Lightning Edge</span>!`);
        updateBattleUI();
        await sleep(2000);
        // Run Target Triggered Effect Check midway
        for (let status of target.statusEffects) {
            if (status.triggered && status.triggeredFunction) {
                await status.triggeredFunction(target, user, "lightning");
                if (DeathCheck()) return true;
            }
        }
        // Apply damage
        let damage = Math.floor(Math.random() * 3) + 2;
        target.hp = Math.max(0, Math.min(target.maxHp, target.hp - damage));
        logBattle(`<span class="output-text-${user === player ? 'player' : 'enemy'}">${user.name}</span> strikes <span class="output-text-${target === player ? 'player' : 'enemy'}">${target.name}</span> with <span class="output-text-neutral">Lightning Edge</span> for ${damage} damage!`);
        updateBattleUI();
        if (DeathCheck()) return true;
        await sleep(2000);
        // Apply Numb to user
        user.statusEffects.push(StatusEffect.Numb(1, 0));
        logBattle(`<span class="output-text-${user === player ? 'player' : 'enemy'}">${user.name}</span> is afflicted with <span class="output-text-neutral">Numb</span> <span class="status-numb">‚ö°Ô∏è</span>!`);
        updateBattleUI();
        if (DeathCheck()) return true;
        await sleep(2000);
        return true;
    }

    async bite(user, target) {
        let damage = 1;
        let heal = user.hp < user.maxHp ? 1 : 0;
        target.hp = Math.max(0, Math.min(target.maxHp, target.hp - damage));
        target.statusEffects.push(StatusEffect.Bleed(2, 1));
        logBattle(`<span class="output-text-${user === player ? 'player' : 'enemy'}">${user.name}</span> uses <span class="output-text-beast">Bite</span> on <span class="output-text-${target === player ? 'player' : 'enemy'}">${target.name}</span> for ${damage} damage, inflicting <span class="status-bleed">Bleed ü©∏</span>!`);
        updateBattleUI();
        user.hp = Math.min(user.maxHp, user.hp + heal);
        if (heal > 0) {
            logBattle(`<span class="output-text-${user === player ? 'player' : 'enemy'}">${user.name}</span> heals ${heal} HP from <span class="output-text-beast">Bite</span>!`);
            updateBattleUI();
            if (DeathCheck()) return true;
            await sleep(2000);
        }
        if (DeathCheck()) return true;
        await sleep(2000);
        return false;
    }

    async nightTerrorJutsu(user, target) {
        target.statusEffects.push(StatusEffect.Numb(1, 0));
        target.statusEffects.push(StatusEffect.Doom(5, 1));
        logBattle(`<span class="output-text-${user === player ? 'player' : 'enemy'}">${user.name}</span> casts <span class="output-text-genjutsu">Night Terror Jutsu</span> on <span class="output-text-${target === player ? 'player' : 'enemy'}">${target.name}</span>, inflicting <span class="status-numb">Numb ‚ö°Ô∏è</span> and <span class="status-doom">Doom üíÄ</span>!`);
        updateBattleUI();
        if (DeathCheck()) return true;
        await sleep(2000);
        return false;
    }

    async wildFireJutsu(user, target) {
        target.statusEffects = target.statusEffects.filter(e => e.name !== "ShadowCloneEffect" && e.name !== "Swap");
        logBattle(`<span class="output-text-${user === player ? 'player' : 'enemy'}">${user.name}</span> dispels <span class="output-text-${target === player ? 'player' : 'enemy'}">${target.name}</span>'s <span class="output-text-neutral">Shadow Clone</span> and <span class="output-text-neutral">Substitution</span> with <span class="output-text-neutral">Wild Fire Jutsu</span>!`);
        updateBattleUI();
        await sleep(2000);
        for (let status of target.statusEffects) {
            if (status.triggered && status.triggeredFunction) {
                await status.triggeredFunction(target, user, "fire");
                if (DeathCheck()) return true;
            }
        }
        target.statusEffects.push(StatusEffect.Burn(1, 1));
        logBattle(`<span class="output-text-${user === player ? 'player' : 'enemy'}">${user.name}</span> casts <span class="output-text-neutral">Wild Fire Jutsu</span> on <span class="output-text-${target === player ? 'player' : 'enemy'}">${target.name}</span>, inflicting 1 damage from <span class="status-burn">Burn üî•</span>!`);
        updateBattleUI();
        if (DeathCheck()) return true;
        await sleep(2000);
        return true;
    }

    async hellFireJutsu(user, target) {
        target.statusEffects.push(StatusEffect.Doom(5, 1));
        logBattle(`<span class="output-text-${user === player ? 'player' : 'enemy'}">${user.name}</span> afflicts <span class="output-text-${target === player ? 'player' : 'enemy'}">${target.name}</span> with <span class="output-text-neutral">Doom</span> <span class="status-doom">üíÄ</span> for 5 turns!`);
        updateBattleUI();
        if (DeathCheck()) return true;
        await sleep(2000);
        target.statusEffects.push(StatusEffect.Burn(1, 2));
        logBattle(`<span class="output-text-${user === player ? 'player' : 'enemy'}">${user.name}</span> casts <span class="output-text-neutral">Hell Fire Jutsu</span> on <span class="output-text-${target === player ? 'player' : 'enemy'}">${target.name}</span>, inflicting 2 damage from <span class="status-burn">Burn üî•</span>!`);
        updateBattleUI();
        if (DeathCheck()) return true;
        await sleep(2000);
        return true;
    }
    }

function compareRanks(rank1, rank2) {
    const ranks = ["D-Rank", "C-Rank", "B-Rank", "A-Rank", "S-Rank"];
    return ranks.indexOf(rank1) - ranks.indexOf(rank2);
    }

// Map Data
const MapData = {
    "Newb Village": {
        areas: ["Academy"],
        isVillage: true
    },
    "Abandoned Village": {
        areas: ["Burnt Tower"],
        isVillage: true
    },
    "Academy": {
        areas: ["Newb Village"],
        isVillage: false
    },
    "Burnt Tower": {
        areas: ["Abandoned Village"],
        isVillage: false
    }
};

// Enemy Generation
function generateEnemySkills(rank, styles) {
    let skillSet = new Skills();
    let availableSkills = skillSet.skills.filter(skill => 
        Object.keys(skill.requirements).every(style => styles[style] && compareRanks(styles[style], skill.requirements[style]) >= 0)
    );
    let selectedSkills = [];
    for (let i = 0; i < 6 && availableSkills.length > 0; i++) {
        let index = Math.floor(Math.random() * availableSkills.length);
        selectedSkills.push(availableSkills.splice(index, 1)[0]);
    }
    return selectedSkills.length > 0 ? selectedSkills : [skillSet.findSkill("Barrage")];
}

function generateEnemy() {
    let styles = ["Fire", "Lightning", "Earth", "Water", "Wind", "Beast", "Ninjutsu", "Taijutsu", "Genjutsu"];
    let styleCount = { Genin: 2, Chunin: 4, Jounin: 6 }[player.rank] || 2;
    let rank = { Student: "C-Rank", Genin: "C-Rank", Chunin: "B-Rank", Jounin: "A-Rank" }[player.rank] || "C-Rank";
    let hp = { Genin: 12, Chunin: 16, Jounin: 20 }[player.rank] || 12;
    let randomStyles = {};
    for (let i = 0; i < styleCount; i++) {
        let style = styles.splice(Math.floor(Math.random() * styles.length), 1)[0];
        randomStyles[style] = rank;
    }
    let skills = generateEnemySkills(rank, randomStyles);
    let name = player.rank === "Genin" ? "Genin Opponent" : player.rank === "Chunin" ? "Chunin Opponent" : "Genin Opponent";
    return new Mob(name, hp, hp, rank, randomStyles, skills, [], [], "https://raw.githubusercontent.com/Mikiiill/NinjaStoryArt/refs/heads/main/Assets/f9e3356c-001c-4196-b356-850eff715d9d-1.png");
}

function generateTrainingEnemy() {
    let enemies = [
        new Mob("Rabid Dog", 8, 8, "D-Rank", { Beast: "C-Rank" }, [new Skills().findSkill("Bite")], [], [], 
                "https://raw.githubusercontent.com/Mikiiill/NinjaStoryArt/refs/heads/main/Assets/d59586a1-0e7d-4016-9d95-eb3d8c8e0a31.jpg"),
        new Mob("Thief", 10, 10, "D-Rank", { Taijutsu: "D-Rank" }, [
            new Skills().findSkill("Barrage"),
            new Skills().findSkill("Barrage"),
            new Skills().findSkill("Substitution Jutsu")
        ], [], [], 
                "https://raw.githubusercontent.com/Mikiiill/NinjaStoryArt/refs/heads/main/Assets/462901d5-cb67-4634-8d4c-ce6522a5313c.jpg"),
        new Mob("Training Dummy", 6, 6, "D-Rank", { Ninjutsu: "D-Rank" }, [new Skills().findSkill("Healing Stance")], [], [], 
                "https://raw.githubusercontent.com/Mikiiill/NinjaStoryArt/refs/heads/main/Assets/8c27baea-3995-49e8-89ae-c5b098b9769a.jpg")
    ];
    return enemies[Math.floor(Math.random() * enemies.length)];
}

// Utility Functions
function logBattle(message, isTutorial = false) {
    const log = document.getElementById("battle-log-content");
    if (log) {
        const newMessage = document.createElement("p");
        newMessage.innerHTML = isTutorial ? `<span class="tutorial-message">${message}</span>` : message;
        log.appendChild(newMessage);
        log.scrollTop = log.scrollHeight;
        newMessage.scrollIntoView({ behavior: "smooth", block: "end" });
    } else {
        console.error("battle-log-content not found");
    }
}

function queueOutput(message) {
    logBattle(message);
}

// Close All Menus
function closeAllMenus() {
    const jutsuManagement = document.getElementById("jutsu-management-content");
    const jutsuSelect = document.querySelector(".jutsu-select");
    const travelControls = document.getElementById("travel-controls");
    if (jutsuManagement) jutsuManagement.classList.add("hidden");
    if (jutsuSelect) jutsuSelect.classList.add("hidden");
    if (travelControls) travelControls.classList.add("hidden");
}

// Jutsu Menu Toggle
let inBattle = false;
let player;

function toggleJutsuMenu() {
    if (inBattle) {
        logBattle(`Cannot toggle Jutsu menu during battle! inBattle: ${inBattle}`);
        return;
    }
    const content = document.getElementById("jutsu-management-content");
    const fightControls = document.getElementById("fight-controls");
    if (content && fightControls) {
        closeAllMenus();
        content.classList.toggle("hidden");
        if (!content.classList.contains("hidden")) {
            fightControls.classList.add("hidden");
        } else {
            fightControls.classList.remove("hidden");
        }
    } else {
        logBattle("Error: jutsu-management-content or fight-controls not found");
    }
}

function closeJutsuMenu() {
    if (inBattle) {
        logBattle(`Cannot close Jutsu menu during battle! inBattle: ${inBattle}`);
        return;
    }
    const content = document.getElementById("jutsu-management-content");
    const fightControls = document.getElementById("fight-controls");
    if (content && fightControls) {
        content.classList.add("hidden");
        fightControls.classList.remove("hidden");
    } else {
        logBattle("Error: jutsu-management-content or fight-controls not found");
    }
}

// Jutsu Selection
const skills = new Skills();

function openJutsuSelect() {
    if (inBattle) {
        logBattle(`Cannot select Jutsu during battle! inBattle: ${inBattle}`);
        return;
    }
    const optionsDiv = document.getElementById("jutsu-options");
    const fightControls = document.getElementById("fight-controls");
    if (optionsDiv && fightControls) {
        closeAllMenus();
        optionsDiv.innerHTML = "";
        const eligibleJutsu = skills.skills.filter(jutsu => skills.canUseSkill(player, jutsu));
        const shuffled = eligibleJutsu.sort(() => 0.5 - Math.random()).slice(0, 3);
        shuffled.forEach(jutsu => {
            const card = document.createElement("div");
            card.className = "jutsu-card";
            card.innerHTML = `
                <h4>${jutsu.name}</h4>
                <p>Style: ${jutsu.style}</p>
                <p>Rank: ${jutsu.rank}</p>
            `;
            card.onclick = () => addJutsuToInventory(jutsu);
            optionsDiv.appendChild(card);
        });
        const jutsuSelect = document.querySelector(".jutsu-select");
        if (jutsuSelect) {
            jutsuSelect.classList.remove("hidden");
            fightControls.classList.add("hidden");
            optionsDiv.scrollIntoView({ behavior: "smooth", block: "start" });
        } else {
            logBattle("Error: jutsu-select not found");
        }
    } else {
        logBattle("Error: jutsu-options or fight-controls not found");
    }
}

function closeJutsuSelect() {
    const jutsuSelect = document.querySelector(".jutsu-select");
    const fightControls = document.getElementById("fight-controls");
    if (jutsuSelect && fightControls) {
        closeAllMenus();
        fightControls.classList.remove("hidden");
    } else {
        logBattle("Error: jutsu-select or fight-controls not found");
    }
}

function addJutsuToInventory(jutsu) {
    const totalCopies = player.activeJutsu.concat(player.inventory).filter(j => j.name === jutsu.name).length;
    if (totalCopies >= 4) {
        logBattle(`Cannot add ${jutsu.name}: Max 4 copies allowed!`);
        return;
    }
    player.inventory.push(jutsu);
    player.activeJutsu.push(player.inventory.pop());
    updateJutsuDisplay();
    closeJutsuSelect();
    if (game.tutorialState && game.tutorialState.jutsuSelectionsRemaining > 0) {
        game.tutorialState.jutsuSelectionsRemaining -= 1;
        logBattle(`<span class="tutorial-message">Jutsu selected! ${game.tutorialState.jutsuSelectionsRemaining} more to select.</span>`, true);
        if (game.tutorialState.jutsuSelectionsRemaining > 0) {
            setTimeout(openJutsuSelect, 1000);
        } else {
            const specificJutsus = [
                skills.findSkill("Substitution Jutsu"),
                skills.findSkill("Barrage"),
                skills.findSkill("Barrage"),
                skills.findSkill("Healing Stance")
            ];
            specificJutsus.forEach(jutsu => {
                if (jutsu && player.activeJutsu.concat(player.inventory).filter(j => j.name === jutsu.name).length < 4) {
                    player.inventory.push(jutsu);
                    player.activeJutsu.push(player.inventory.pop());
                }
            });
            logBattle(`<span class="tutorial-message">Equipped 6 Jutsus: ${player.activeJutsu.map(j => j.name).join(", ")}</span>`, true);
            game.tutorialState = null;
            logBattle(`<span class="tutorial-message">Tutorial completed! Welcome to Newb Village!</span>`, true);
            logBattle(`<span class="tutorial-message">Train 10 times to obtain a new Jutsu. Jutsu appear based on your Fighting Style Ranks.</span>`, true);
            logBattle(`<span class="tutorial-message">Reach 10 jutsu to become a Genin.</span>`, true);
            ArriveVillage("Newb Village");
        }
    }
}

// Rank Up Selection
function openRankUpSelect() {
    if (inBattle) {
        logBattle(`Cannot rank up during battle! inBattle: ${inBattle}`);
        return;
    }
    const optionsDiv = document.getElementById("jutsu-options");
    const fightControls = document.getElementById("fight-controls");
    if (optionsDiv && fightControls) {
        closeAllMenus();
        optionsDiv.innerHTML = "";
        const availableStyles = ["Ninjutsu", "Genjutsu", "Taijutsu", "Fire", "Lightning", "Earth"];
        availableStyles.forEach(style => {
            const currentRank = player.fightingStyles[style] || "None";
            const card = document.createElement("div");
            card.className = "jutsu-card";
            card.innerHTML = `
                <h4>${style}</h4>
                <p>Current Rank: ${currentRank}</p>
            `;
            card.onclick = () => upgradeFightingStyle(style);
            optionsDiv.appendChild(card);
        });
        const jutsuSelect = document.querySelector(".jutsu-select");
        if (jutsuSelect) {
            jutsuSelect.classList.remove("hidden");
            fightControls.classList.add("hidden");
            optionsDiv.scrollIntoView({ behavior: "smooth", block: "start" });
            
        } else {
            logBattle("Error: jutsu-select not found");
        }
    } else {
        logBattle("Error: jutsu-options or fight-controls not found");
    }
}

function upgradeFightingStyle(style) {
    if (inBattle) {
        logBattle(`Cannot upgrade fighting style during battle! inBattle: ${inBattle}`);
        return;
    }
    if (!game.rankUpPoints || game.rankUpPoints <= 0) {
        logBattle("No RANKUP points remaining!");
        closeJutsuSelect();
        return;
    }
    const ranks = ["D-Rank", "C-Rank", "B-Rank", "A-Rank", "S-Rank"];
    const currentRank = player.fightingStyles[style] || "None";
    let newRank;
    if (currentRank === "None") {
        newRank = "C-Rank";
    } else if (currentRank === "S-Rank") {
        logBattle(`${style} is already at maximum rank (S-Rank)!`);
        return;
    } else {
        const currentIndex = ranks.indexOf(currentRank);
        newRank = ranks[currentIndex + 1];
    }
    player.fightingStyles[style] = newRank;
    game.rankUpPoints -= 1;
    logBattle(`<span class="tutorial-message">Upgraded ${style} to ${newRank}! ${game.rankUpPoints} RANKUP point(s) remaining.</span>`, game.tutorialState !== null);
    if (game.rankUpPoints === 0) {
        closeJutsuSelect();
        if (game.tutorialState && game.tutorialState.phase === "rankUp") {
            game.tutorialState.phase = "jutsuSelection";
            game.tutorialState.jutsuSelectionsRemaining = 4;
            logBattle(`<span class="tutorial-message">Rank Up complete! Now select 4 starting Jutsu.</span>`, true);
            setTimeout(openJutsuSelect, 1000);
        }
    } else {
        openRankUpSelect();
    }
    updateJutsuDisplay();
}

// Jutsu Management
function updateJutsuDisplay() {
    const activeDiv = document.getElementById("active-jutsu");
    const inventoryDiv = document.getElementById("inventory-jutsu");
    if (activeDiv && inventoryDiv) {
        activeDiv.innerHTML = "";
        inventoryDiv.innerHTML = "";
        // Process activeJutsu
        const activeJutsuShown = new Set();
        player.activeJutsu.forEach((jutsu, index) => {
            if (!activeJutsuShown.has(jutsu.name)) {
                const card = document.createElement("div");
                card.className = "jutsu-card";
                const duplicateCount = player.activeJutsu.filter(j => j.name === jutsu.name).length;
                card.innerHTML = `
                    <h4>${jutsu.name}</h4>
                    <p>Style: ${jutsu.style}</p>
                    <p><strong>x${duplicateCount}</strong></p>
                    <button onclick="moveJutsuToInventory(${index})" ${inBattle ? "disabled" : ""}>To Inventory</button>
                `;
                activeDiv.appendChild(card);
                activeJutsuShown.add(jutsu.name);
            }
        });
        // Process inventory
        const inventoryJutsuShown = new Set();
        player.inventory.forEach((jutsu, index) => {
            if (!inventoryJutsuShown.has(jutsu.name)) {
                const card = document.createElement("div");
                card.className = "jutsu-card";
                const duplicateCount = player.inventory.filter(j => j.name === jutsu.name).length;
                card.innerHTML = `
                    <h4>${jutsu.name}</h4>
                    <p>Style: ${jutsu.style}</p>
                    <p><strong>x${duplicateCount}</strong></p>
                    <button onclick="moveJutsuToActive(${index})" ${inBattle ? "disabled" : ""}>To Active</button>
                `;
                inventoryDiv.appendChild(card);
                inventoryJutsuShown.add(jutsu.name);
            }
        });
        const toggleJutsuBtn = document.getElementById("toggle-jutsu-btn");
        if (toggleJutsuBtn) toggleJutsuBtn.disabled = inBattle;
    } else {
        logBattle("Error: active-jutsu or inventory-jutsu not found");
    }
}

function moveJutsuToInventory(index) {
    if (inBattle) {
        logBattle(`Cannot move Jutsu during battle! inBattle: ${inBattle}`);
        return;
    }
    if (player.activeJutsu.length > 0 && index >= 0 && index < player.activeJutsu.length) {
        player.inventory.push(player.activeJutsu.splice(index, 1)[0]);
        updateJutsuDisplay();
    }
}

function moveJutsuToActive(index) {
    if (inBattle) {
        logBattle(`Cannot move Jutsu during battle! inBattle: ${inBattle}`);
        return;
    }
    if (player.activeJutsu.length < 10 && index >= 0 && index < player.inventory.length) {
        const jutsu = player.inventory[index];
        const totalCopies = player.activeJutsu.concat(player.inventory).filter(j => j.name === jutsu.name).length;
        if (totalCopies <= 4) {
            player.activeJutsu.push(player.inventory.splice(index, 1)[0]);
            updateJutsuDisplay();
        } else {
            logBattle(`Cannot equip ${jutsu.name}: Max 4 copies allowed!`);
        }
    }
}

// Travel and Village
function openTravelSelect() {
    if (inBattle) {
        logBattle(`Cannot travel during battle! inBattle: ${inBattle}`);
        return;
    }
    const optionsDiv = document.getElementById("jutsu-options");
    const fightControls = document.getElementById("fight-controls");
    if (optionsDiv && fightControls) {
        closeAllMenus();
        optionsDiv.innerHTML = "";
        const destinations = Object.keys(MapData).filter(loc => loc !== player.lastVillage);
        destinations.forEach(dest => {
            const card = document.createElement("div");
            card.className = "jutsu-card";
            card.innerHTML = `<h4>${dest}</h4>`;
            card.onclick = () => startTravelFight(dest);
            optionsDiv.appendChild(card);
        });
        const jutsuSelect = document.querySelector(".jutsu-select");
        if (jutsuSelect) {
            jutsuSelect.classList.remove("hidden");
            fightControls.classList.add("hidden");
            optionsDiv.scrollIntoView({ behavior: "smooth", block: "start" });
        } else {
            logBattle("Error: jutsu-select not found");
        }
    } else {
        logBattle("Error: jutsu-options or fight-controls not found");
    }
}

function ArriveVillage(village) {
    player.hp = player.maxHp;
    player.statusEffects = [];
    player.lastVillage = village;
    inBattle = false;
    const battleScreen = document.getElementById("battle-screen");
    const fightControls = document.getElementById("fight-controls");
    const travelControls = document.getElementById("travel-controls");
    if (battleScreen && fightControls && travelControls) {
        closeAllMenus();
        battleScreen.classList.add("hidden");
        fightControls.classList.remove("hidden");
        travelControls.classList.add("hidden");
    } else {
        logBattle("Error: battle-screen, fight-controls, or travel-controls not found");
    }
    updateJutsuDisplay();
    updateBattleUI();
    logBattle(`<span class="output-text-neutral">Arrived at ${village}!</span>`);
    
    // Simplified: Just check EXP threshold
    if (player.xp >= 10) {
        player.xp = 0;
        logBattle(`<span class="output-text-neutral">${player.name} has enough EXP to learn a new Jutsu!</span>`);
        setTimeout(() => {
            openJutsuSelect();
        }, 1000);  // Short delay for smooth flow after arrival log
    }
    
    const villageName = document.getElementById("village-name");
    if (villageName) {
        villageName.textContent = village;
    } else {
        logBattle("Error: village-name not found");
    }
    
    // Reset battle type after processing
    game.battleType = null;
}

// Battle System
const game = {
    battleType: null,
    player: null,
    opponent: null,
    user: null,
    target: null,
    targetDestination: null,
    rankUpPoints: 0,
    tutorialState: null,
    battleEnded: false
};

async function awardReward(winner, loser) {
    if (game.battleType === "training") {
        player.xp += 1;
        logBattle(`<span class="output-text-player">${player.name}</span> gained 1 EXP!`);
        await sleep(3000);
        const playerXp = document.getElementById("player-xp");
        if (playerXp) {
            playerXp.textContent = player.xp;
        } else {
            logBattle("Error: player-xp not found");
        }
    }
    updateJutsuDisplay();
}

function DeathCheck() {
    if (!game.user || !game.target) return false;
    
    let winner = null;
    let loser = null;

    if (game.user.hp <= 0 && game.target.hp <= 0) {
        winner = "both";
        loser = "both";
        logBattle(`<span class="output-text-${game.user === player ? 'player' : 'enemy'}">${game.user.name}</span> and <span class="output-text-${game.target === player ? 'player' : 'enemy'}">${game.target.name}</span> are both defeated! Both win!`);
    } else if (game.user.hp <= 0) {
        winner = game.target;
        loser = game.user;
        logBattle(`<span class="output-text-${game.user === player ? 'player' : 'enemy'}">${game.user.name}</span> is defeated! <span class="output-text-${game.target === player ? 'player' : 'enemy'}">${game.target.name}</span> wins!`);
    } else if (game.target.hp <= 0) {
        winner = game.user;
        loser = game.target;
        logBattle(`<span class="output-text-${game.target === player ? 'player' : 'enemy'}">${game.target.name}</span> is defeated! <span class="output-text-${game.user === player ? 'player' : 'enemy'}">${game.user.name}</span> wins!`);
    }

    if (winner) {
        endBattle(winner, loser);
        return true;
    }
    return false;
}

async function startBattle(player, opponent) {
    if (inBattle) {
        logBattle("Battle already in progress!");
        await sleep(3000);
        return;
    }
    if (player.activeJutsu.length === 0) {
        logBattle("Cannot start battle: No active Jutsu equipped!");
        await sleep(3000);
        return;
    }
    inBattle = true;
    game.battleEnded = false;
    game.player = player;
    game.opponent = opponent;
    game.user = null;
    game.target = null;
    const battleScreen = document.getElementById("battle-screen");
    const fightControls = document.getElementById("fight-controls");
    const travelControls = document.getElementById("travel-controls");
    if (battleScreen && fightControls && travelControls) {
        closeAllMenus();
        battleScreen.classList.remove("hidden");
        fightControls.classList.add("hidden");
        travelControls.classList.add("hidden");
    } else {
        logBattle("Error: battle-screen, fight-controls, or travel-controls not found");
        inBattle = false;
        return;
    }
    updateJutsuDisplay();
    updateBattleUI();
    logBattle(`<span class="output-text-player">${game.player.name}</span> vs <span class="output-text-enemy">${game.opponent.name}</span>!`);
    await sleep(1000);
    await setTurnOrder();
}

async function startTrainingFight() {
    if (inBattle) {
        logBattle(`Cannot start Training fights during battle! inBattle: ${inBattle}`);
        return;
    }
    game.battleType = "training";
    const opponent = generateTrainingEnemy();
    logBattle(`Generated enemy: ${opponent.name}, Jutsu: ${opponent.activeJutsu.map(j => j.name).join(", ")}`);
    await startBattle(player, opponent);
}

async function startTravelFight(destination) {
    if (inBattle) {
        logBattle(`Cannot start Travel fights during battle! inBattle: ${inBattle}`);
        return;
    }
    game.battleType = "travel";
    player.travelFightsCompleted = player.travelFightsCompleted || 0;
    game.targetDestination = destination;
    closeJutsuSelect();
    const opponent = generateEnemy();
    logBattle(`Generated enemy: ${opponent.name}, Jutsu: ${opponent.activeJutsu.map(j => j.name).join(", ")}`);
    await startBattle(player, opponent);
}

async function startEventFight() {
    if (inBattle) {
        logBattle(`Cannot start Event fights during battle! inBattle: ${inBattle}`);
        return;
    }
    game.battleType = "event";
    queueOutput("<span class='output-text-neutral'>Event fight started!</span>");
    const opponent = generateEnemy();
    logBattle(`Generated enemy: ${opponent.name}, Jutsu: ${opponent.activeJutsu.map(j => j.name).join(", ")}`);
    await startBattle(player, opponent);
}

async function startArenaFight() {
    if (inBattle) {
        logBattle(`Cannot start Arena fights during battle! inBattle: ${inBattle}`);
        return;
    }
    game.battleType = "arena";
    queueOutput("<span class='output-text-neutral'>Arena fight started!</span>");
    const opponent = generateEnemy();
    logBattle(`Generated enemy: ${opponent.name}, Jutsu: ${opponent.activeJutsu.map(j => j.name).join(", ")}`);
    await startBattle(player, opponent);
}

async function endBattle(winner, loser) {
    if (game.battleEnded) return;
    game.battleEnded = true;
    inBattle = false;  // Reset early to unblock menus/UI
    game.user = null;
    game.target = null;
    await sleep(3000);
    await awardReward(winner, loser);  // Now safe to open Jutsu select if triggered
    game.player = player;
    game.opponent = null;
    const battleScreen = document.getElementById("battle-screen");
    const fightControls = document.getElementById("fight-controls");
    const travelControls = document.getElementById("travel-controls");
    if (battleScreen && fightControls && travelControls) {
        closeAllMenus();
        battleScreen.classList.add("hidden");
        if (game.battleType === "travel" && winner === game.player) {
            player.travelFightsCompleted = (player.travelFightsCompleted || 0) + 1;
            queueOutput(`<span class='output-text-neutral'>Travel fight completed! ${player.travelFightsCompleted}/4 fights done.</span>`);
            await sleep(3000);
            if (player.travelFightsCompleted < 4) {
                await startTravelFight(game.targetDestination);
            } else {
                player.travelFightsCompleted = 0;
                ArriveVillage(game.targetDestination);
            }
        } else {
            player.travelFightsCompleted = 0;
            ArriveVillage(player.lastVillage);
        }
    } else {
        logBattle("Error: battle-screen, fight-controls, or travel-controls not found");
    }
    queueOutput("<span class='battle-ready'>Battle ended!</span>");
    updateJutsuDisplay();
    updateBattleUI();
}

async function setTurnOrder() {
    if (Math.random() < 0.5) {
        game.user = game.player;
        game.target = game.opponent;
        logBattle(`<span class="output-text-player">${game.player.name}</span> goes first!`);
    } else {
        game.user = game.opponent;
        game.target = game.player;
        logBattle(`<span class="output-text-enemy">${game.opponent.name}</span> goes first!`);
    }
    await sleep(1000);
    await takeTurn();
}

async function takeTurn() {
    if (!inBattle) {
        logBattle("Battle stopped unexpectedly!");
        await sleep(3000);
        return;
    }
    try {
        updateBattleUI();
        logBattle("");
        logBattle(`‚úß‚úß <strong><span class="output-text-${game.user === player ? 'player' : 'enemy'}">${game.user.name}'s Turn</span></strong> ‚úß‚úß`);
        await sleep(1000);
        let skipTurn = false;
        let battleEnded = false;
        for (let status of game.user.statusEffects) {
            if (status.startOfTurn && status.startOfTurnFunction) {
                if (await status.startOfTurnFunction(game.user, game.target, status)) {
                    skipTurn = true;
                }
                if (DeathCheck()) {
                    battleEnded = true;
                    break;
                }
                if (!inBattle) {
                    battleEnded = true;
                    break;
                }
            }
            if (battleEnded) break;
            status.duration--;
            if (!inBattle) {
                battleEnded = true;
                break;
            }
        }
        if (battleEnded) return;
        game.user.statusEffects = game.user.statusEffects.filter(status => status.duration > 0);
        updateBattleUI();
        if (DeathCheck()) return;
        if (skipTurn) {
            logBattle(`${game.user.name} is recovering!`);
            await sleep(2000);
            // Add Recovered status to user
            game.user.statusEffects.push(recoveredStatus(1, 0));
                
            updateBattleUI();
            await endTurn();
            return;
        }
        await skillAction();
    } catch (e) {
        logBattle(`Error in takeTurn: ${e.message}`);
        await sleep(3000);
        inBattle = false;
    }
}

async function skillAction() {
    try {
        if (!game.user.activeJutsu.length) {
            logBattle(`${game.user.name} has no Active Jutsu!`);
            await sleep(2000);
            await endTurn();
            return;
        }
        const jutsu = game.user.activeJutsu[Math.floor(Math.random() * game.user.activeJutsu.length)];
        logBattle(`<span class="output-text-${game.user === player ? 'player' : 'enemy'}">${game.user.name}</span> uses ${jutsu.name}!`);
        await sleep(2000);
        for (let status of game.user.statusEffects) {
            if (status.active && status.activeFunction) {
                await status.activeFunction(game.user, game.target);
                if (DeathCheck()) return;
            }
            status.new = false;
        }
        if (jutsu.support) {
            await jutsu.skillFunction(game.user, game.target);
            if (DeathCheck()) return;
            await endTurn();
            return;
        }
        for (let status of game.target.statusEffects) {
            if (status.triggered && status.triggeredFunction) {
                await status.triggeredFunction(game.target, game.user, jutsu.style);
                if (DeathCheck()) return;
            }
        }
        await jutsu.skillFunction(game.user, game.target);
        if (DeathCheck()) return;
        await endTurn();
    } catch (e) {
        logBattle(`Error in skillAction: ${e.message}`);
        await sleep(3000);
        inBattle = false;
    }
}

async function endTurn() {
    try {
        if (!inBattle) {
            await sleep(1000);
            return;
        }

        // User endOfTurn status effect check
        let battleEnded = false;
        for (let status of game.user.statusEffects) {
            if (status.endOfTurn && status.endOfTurnFunction) {
                await status.endOfTurnFunction(game.user, game.target, status);
                if (DeathCheck()) {
                    battleEnded = true;
                    break;
                }
                if (!inBattle) {
                    battleEnded = true;
                    break;
                }
            }
            if (battleEnded) break;
        }
        if (battleEnded) return;
        game.user.statusEffects = game.user.statusEffects.filter(status => status.duration > 0);
        updateBattleUI();
        if (DeathCheck()) return;

        // Target endOfTurn status effect check
        for (let status of game.target.statusEffects) {
            if (status.endOfTurn && status.endOfTurnFunction) {
                await status.endOfTurnFunction(game.target, game.user, status);
                if (DeathCheck()) {
                    battleEnded = true;
                    break;
                }
                if (!inBattle) {
                    battleEnded = true;
                    break;
                }
            }
            if (battleEnded) break;
        }
        if (battleEnded) return;
        game.target.statusEffects = game.target.statusEffects.filter(status => status.duration > 0);
        updateBattleUI();
        if (DeathCheck()) return;
        //await sleep(1000); //felt laggy

        [game.user, game.target] = [game.target, game.user];
        updateBattleUI();
        setTimeout(takeTurn, 1000);
    } catch (e) {
        logBattle(`Error in endTurn: ${e.message}`);
        await sleep(1000);
        inBattle = false;
    }
}

function updateBattleUI() {
    try {
        const userName = document.getElementById("user-name");
        const userHp = document.getElementById("user-hp");
        const userStatus = document.getElementById("user-status");
        const userSprite = document.getElementById("user-sprite");
        const opponentName = document.getElementById("opponent-name");
        const opponentHp = document.getElementById("opponent-hp");
        const opponentStatus = document.getElementById("opponent-status");
        const opponentSprite = document.getElementById("opponent-sprite");
        const playerRank = document.getElementById("player-rank");
        const playerXp = document.getElementById("player-xp");
        const villageInfo = document.getElementById("village-info");
        if (!userName || !userHp || !userStatus || !userSprite || !opponentName || !opponentHp || !opponentStatus || !opponentSprite || !playerRank || !playerXp || !villageInfo) {
            logBattle("Error: One or more UI elements missing in updateBattleUI!");
            inBattle = false;
            return;
        }
        userName.textContent = game.player ? game.player.name : "None";
        userHp.textContent = game.player ? `${game.player.hp}/${game.player.maxHp}` : "0/0";
        userStatus.textContent = game.player ? game.player.statusEffects.map(s => statusEmojis[s.name] || s.name).join(" ") : "None";
        userSprite.src = game.player ? game.player.sprite : "";
        opponentName.textContent = game.opponent ? game.opponent.name : "None";
        opponentHp.textContent = game.opponent ? `${game.opponent.hp}/${game.opponent.maxHp}` : "0/0";
        opponentStatus.textContent = game.opponent ? game.opponent.statusEffects.map(s => statusEmojis[s.name] || s.name).join(" ") : "None";
        opponentSprite.src = game.opponent ? game.opponent.sprite : ""; // Changed to use game.opponent.sprite first
        playerRank.textContent = game.player ? game.player.rank : "None";
        playerXp.textContent = game.player ? game.player.xp : 0;
        villageInfo.classList.toggle("battle-mode", inBattle);
    } catch (e) {
        logBattle(`Error in updateBattleUI: ${e.message}`);
        inBattle = false;
    }
}

// Character Selection Functions
function startGame() {
    const characterSelect = document.getElementById("character-select");
    if (characterSelect) {
        characterSelect.classList.remove("hidden");
    } else {
        logBattle("Error: character-select not found", true);
        startTutorial(); // Fallback to original tutorial if modal fails
    }
}

function selectSprite(url) {
    player.sprite = url;
    const cards = document.querySelectorAll(".sprite-card");
    cards.forEach(card => card.style.borderColor = "#ccc");
    event.currentTarget.style.borderColor = "#000"; // Highlight selected
}

function confirmCharacter() {
    const nameInput = document.getElementById("player-name");
    if (nameInput && nameInput.value.trim() && player.sprite && player.sprite !== "https://raw.githubusercontent.com/Mikiiill/ShinobiWay/refs/heads/main/Assets/NINJA1.PNG") {
        player.name = nameInput.value.trim();
        const characterSelect = document.getElementById("character-select");
        if (characterSelect) characterSelect.classList.add("hidden");
        startTutorial();
    } else {
        logBattle("Please enter a name and select a unique sprite!", true);
    }
}

async function startTutorial() {
    logBattle("Welcome to Ninja Story! Let's begin your training.", true);
    await sleep(3000);
    logBattle("First, select two fighting styles to rank up!", true);
    await sleep(3000);
    game.tutorialState = {
        phase: "rankUp",
        jutsuSelectionsRemaining: 0
    };
    game.rankUpPoints = 2;
    openRankUpSelect();
}

// Additional Functions for NPC and Village
function talkToNPC() {
    if (inBattle) {
        logBattle(`Cannot talk to NPC during battle! inBattle: ${inBattle}`);
        return;
    }
    if (game.player.activeJutsu.length >= 10 && game.player.rank === "Student") {
        game.player.rank = "Genin";
        game.player.maxHp = 12; // Set max HP to 12 on promotion
        game.player.hp = Math.min(game.player.hp, game.player.maxHp); // Adjust current HP if it exceeds max
        logBattle(`<span class="output-text-player">${game.player.name}</span> has been promoted to Genin! Max HP increased to 12!`);
        const playerRank = document.getElementById("player-rank");
        if (playerRank) {
            playerRank.textContent = game.player.rank;
        }
        updateBattleUI();
        // Trigger style selection with 1 rank-up point, mimicking tutorial
        game.rankUpPoints = 1;
        logBattle("Select a fighting style to rank up as a reward!", true);
        openRankUpSelect(); // Use same modal-based selection as tutorial
    } else {
        logBattle("You need 10 Jutsu to become a Genin! Keep training!");
    }
}

function returnToVillage() {
    if (inBattle) {
        logBattle(`Cannot return to village during battle! inBattle: ${inBattle}`);
        return;
    }
    ArriveVillage(game.player.lastVillage);
}

// Assign Random Jutsu (Optional, added for consistency with LaterGameJS)
function assignRandomJutsu(mob, count) {
    const eligibleJutsu = skills.skills.filter(jutsu => skills.canUseSkill(mob, jutsu));
    if (eligibleJutsu.length === 0) {
        logBattle("Error: No eligible Jutsu found! Assigning Barrage as fallback.");
        console.error("No eligible Jutsu", mob.fightingStyles, skills.skills.map(s => ({ name: s.name, requirements: s.requirements })));
        mob.activeJutsu = [skills.findSkill("Barrage")];
        return;
    }
    const shuffled = eligibleJutsu.sort(() => 0.5 - Math.random()).slice(0, count);
    mob.activeJutsu = shuffled;
    logBattle(`Assigned ${count} Jutsu to ${mob.name}: ${shuffled.map(j => j.name).join(", ") || "None"}`);
}

// Initialize Game
function initializeGame() {
    try {
        player = new Mob(
            "Shinobi",
            10,
            10,
            "Student",
            { Ninjutsu: "D-Rank", Taijutsu: "D-Rank", Genjutsu: "D-Rank" },
            [],
            [],
            [],
            "https://raw.githubusercontent.com/Mikiiill/ShinobiWay/refs/heads/main/Assets/NINJA1.PNG"
        );
        game.player = player;
        inBattle = false;
        updateJutsuDisplay();
        updateBattleUI();
        logBattle("<span class='output-text-neutral'>Game initialized!</span>");
        startGame();
    } catch (e) {
        console.error("Error in initializeGame:", e.message);
        startTutorial(); // Ensure tutorial starts even if UI fails
    }
}

async function startArenaFightWithFriend() {
    if (inBattle) {
        logBattle(`Cannot start Arena fight during battle! inBattle: ${inBattle}`);
        return;
    }
    const password = prompt("Enter your friend's password to start an Arena fight:");
    if (!password) {
        logBattle(`<span class="output-text-neutral">No password provided. Arena fight canceled.</span>`);
        return;
    }
    try {
        const decoded = atob(password);
        const friendData = JSON.parse(decoded);
        const skills = new Skills(); // Reinitialize Skills to access full BattleSkill definitions
        const friendOpponent = new Mob(
            `${friendData.name}`, // Unique name for the opponent
            friendData.hp,
            friendData.maxHp,
            friendData.rank,
            friendData.fightingStyles,
            friendData.activeJutsu.map(j => skills.findSkill(j.name) || new BattleSkill(j.name, [], {}, () => {}, j.style, j.support, j.rank)), // Map to full skills
            friendData.inventory.map(j => skills.findSkill(j.name) || new BattleSkill(j.name, [], {}, () => {}, j.style, j.support, j.rank)),
            friendData.statusEffects.map(s => new StatusEffect(s.name, s.duration, s.damage)),
            friendData.sprite
        );
        opponent = friendOpponent; // Set the global opponent
        game.battleType = "arena";
        logBattle(`Generated opponent: ${opponent.name}, Jutsu: ${opponent.activeJutsu.map(j => j.name).join(", ")}`);
        await startBattle(player, opponent); // Use global player and opponent
    } catch (e) {
        logBattle(`<span class="output-text-neutral">Invalid friend password: ${e.message}</span>`);
    }
}


// Wait for DOM ready before initializing
if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', initializeGame);
} else {
    initializeGame();
}

initializeGame();
